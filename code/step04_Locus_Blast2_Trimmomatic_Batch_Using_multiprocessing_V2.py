# Date: 20251128
# Author: Linchun Shi, Yanda Zhu
# Copyright: (c) 2025 Linchun Shi, Yanda Zhu. All rights reserved.

####################################################
import sys
import os
import shutil
from Bio import SeqIO
import fnmatch
import subprocess
import multiprocessing
import time
import argparse

####################################################

"""
Purpose:
------------
    * BLAST each sample against a user-provided gene CDS database. And extract hit reads in FASTQ format with seqtk for downstream assembly or mapping.
    ** Process every sample subdirectory generated by Trimmomatic (step03).
Usage:
------------
    python Locus_Blast2_Trimmomatic_Batch_Using_multiprocessing.py /path/to/TrimmomaticOutDir /path/to/locus_database /path/to/LocusOutDir [-g/--gene <gene1> <gene2> ...]

Workflow:
------------
    1. Set input parameters;
    2. Create dict {gene:path_to_gene_fasta} from <databaseDir>;
    3. For each sample sub-folder in <trimmomaticDir>:
        (1) create /Fasta sub-folder,
        (2) convert R1/R2.paired.fastq.gz → .paired.fasta via seqkit fq2fa,
        (3) build BLAST db with makeblastdb;
    4. For each gene (or 'all') requested by user:
        (1) create gene-specific output sub-folder,
        (2) run blastn (megablast, e-value 1e-06, max_target_seqs 100000),
        (3) merge R1+R2 BLAST hits, filter by identity & length,
        (4) extract hit reads from original FASTQ via seqtk subseq;
    5. Run all commands in parallel (4 worker processes by default) and wait until completion, print each command before execution for logging/debugging.

Notes:
------------
    * Locus_Blast2_Trimmomatic_Batch_Using_multiprocessing.py -h/--help for help.
    * Gene database files must be named <GENE>_*.fasta (case-insensitive) in <databaseDir>.
    * If the quality-controlled data not from step02, the data format must be <workdir>/<sample>/R1(or R2).paired.fastq.gz.
    * Output files are written as <sample>.<locus>.R1/R2.fastq alongside <sample>.<locus>.R18R2.B.E06.O.sbjct.list.
    * The script will skip if the target files already exist and are non-empty, allowing safe re-runs.
    * Adjust ‘processes=’ in the multiprocessing.Pool call to match local CPU/memory resources.
"""

#####################################################
def args_parse():
	parser = argparse.ArgumentParser(description="This script is used to run Locus_Blast2_Trimmomatic_Batch_Using_multiprocessing", formatter_class=argparse.RawTextHelpFormatter)
	parser.add_argument('trimmomaticDir', help='path to trimmomaticDir')
	parser.add_argument('databaseDir', help='path to databaseDir')
	parser.add_argument('outdir', help='path to outdir')
	parser.add_argument('-g', '--gene', type=str, default='all', nargs='+', metavar='str', help='the name of gene to be assembled, support multi gene input(default: "all") :\n'
																					 '1.gene1;\n2.gene1 gene2 ... geneN;\n3.all'
																					 )
	parser.add_argument('-st', type=int, default=32, help='the number of threads to use for seqkit (default: 32)')
	parser.add_argument('-bt', type=int, default=32, help='the number of processes to use for blastn (default: 32)')
	return parser.parse_args()

def main():
	args = args_parse()
	return args.trimmomaticDir, args.databaseDir, args.outdir, args.gene, args.st, args.bt

def create_database_dict_and_get_L_locus(databaseDir, marker):
	# create_database_dict
	D_queryFile = {}
	for file in fnmatch.filter(os.listdir(databaseDir), '*.fasta'):
		if '_' in file:
			geneName = file.split('_')[0].lower()
			filePath = os.path.join(databaseDir, file)
			D_queryFile[geneName] = filePath

	# get_L_locus
	L_locus = []
	if marker == 'all':
		for key in D_queryFile.keys():
			L_locus.append(key)
	else:
		for i in marker:
			if i.strip().lower() == 'all':
				if len(marker) == 1:
					for key in D_queryFile.keys():
						L_locus.append(key)
				else:
					sys.exit(f"Error: input!!! input marker exist 'all' and other genes")
			else:
				if i.strip().lower() in D_queryFile.keys():
					L_locus.append(i.strip().lower())
				else:
					sys.exit(f"Error: input!!! input marker '{i}' does not exist in databaseDir")
	if L_locus and D_queryFile:
		return D_queryFile, L_locus
	elif not L_locus:
		sys.exit(f"Error: input!!! input marker '{marker}' does not exist in databaseDir")
	elif not D_queryFile:
		sys.exit(f"Error: input!!! databaseDir {databaseDir} does not exist in databaseDir")


def step1_fastq_to_fasta(workdir, st):
	print("step1: Convert Fastq2Fasta")

	if not shutil.which("seqkit"):
		sys.exit("seqkit not found in PATH")
	if not shutil.which("blastn"):
		sys.exit("blastn not found in PATH")
	if not shutil.which("seqtk"):
		sys.exit("seqtk not found in PATH")

	for sub_workdir in os.listdir(workdir):
		os.makedirs(workdir + "/" + sub_workdir + "/Fasta", exist_ok=True)

		R1FastqFile = workdir + "/" + sub_workdir + "/" + sub_workdir + ".R1.paired.fastq.gz"
		R1FastaFile = workdir + "/" + sub_workdir + "/Fasta/" + sub_workdir + ".R1.paired.fasta"

		if not os.path.exists(R1FastaFile) or os.path.getsize(R1FastaFile) == 0:
			cmd_convertFastq2FastaR1 = f"seqkit fq2fa {R1FastqFile} -j {st} -o {R1FastaFile}"
			print(cmd_convertFastq2FastaR1)
			P1 = subprocess.Popen(cmd_convertFastq2FastaR1, shell=True)
			P1.wait()
		else:
			print("-----Fastq2Fasta is OK\t", R1FastaFile)

		R2FastqFile = workdir + "/" + sub_workdir + "/" + sub_workdir + ".R2.paired.fastq.gz"
		R2FastaFile = workdir + "/" + sub_workdir + "/Fasta/" + sub_workdir + ".R2.paired.fasta"
		if not os.path.exists(R2FastaFile) or os.path.getsize(R2FastaFile) == 0:
			cmd_convertFastq2FastaR2 = f"seqkit fq2fa {R2FastqFile} -j {st} -o {R2FastaFile}"
			print(cmd_convertFastq2FastaR2)
			P2 = subprocess.Popen(cmd_convertFastq2FastaR2, shell=True)
			P2.wait()
		else:
			print("-----Fastq2Fasta is OK\t", R2FastaFile)

def step2_make_formatdb(workdir):
	print("step2:formatdb")
	L_Process_formatdb = []

	for sub_workdir in os.listdir(workdir):
		for workfile in fnmatch.filter(os.listdir(workdir + "/" + sub_workdir + "/Fasta"), "*.paired.fasta"):
			databaseInputFile = workdir + "/" + sub_workdir + "/Fasta/" + workfile
			databaseFile = workdir + "/" + sub_workdir + "/Fasta/" + workfile + ".ndb"
			if not os.path.exists(databaseFile) or os.path.getsize(databaseFile) == 0:
				formatdbCmd = f"makeblastdb -in {databaseInputFile} -dbtype nucl -parse_seqids -out {databaseInputFile}"
				L_Process_formatdb.append(formatdbCmd)
			else:
				print("+++++makeblastdb is OK\t", databaseFile)
	return L_Process_formatdb

def run_formatdb(name):
	my_Cmd = name
	print("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
	print(my_Cmd)
	subprocess.call(my_Cmd, shell=True)

def step3_run_blast(workdir, D_queryFile, L_locus, bt):
	print("step3:run blast")

	L_Process_Blast = []

	for sub_workdir in os.listdir(workdir):
		if os.path.isdir(workdir + "/" + sub_workdir):
			os.makedirs(outdir + "/" + sub_workdir, exist_ok=True)
			for locus in L_locus:
				os.makedirs(outdir + "/" + sub_workdir + "/" + locus, exist_ok=True)
				for dbFile in fnmatch.filter(os.listdir(workdir + "/" + sub_workdir + "/Fasta/"), "*.fasta"):
					blastOutFile = outdir + "/" + sub_workdir + "/" + locus + "/" + dbFile + ".B.E06.O"
					blastbaseDir = workdir + "/" + sub_workdir + "/Fasta/" + dbFile
					if not os.path.exists(blastOutFile) or os.path.getsize(blastOutFile) == 0:
						locus_cmd = f"blastn -query {D_queryFile[locus]} -db {blastbaseDir} -outfmt 6 -max_target_seqs 100000 -num_threads {bt} -task megablast -out {blastOutFile}"
						L_Process_Blast.append(locus_cmd)
					else:
						print("-----runBlast is OK\t", blastOutFile)
	return L_Process_Blast


def run_blast(name):
	my_Cmd = name
	print("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
	print(my_Cmd)
	subprocess.call(my_Cmd, shell=True)

def findUniqBlastHitList(L_BlastOutFile, outListFile, align_length_cutoff):
	D = {}
	for BlastOutFile in L_BlastOutFile:
		for line in open(BlastOutFile):
			line = line.strip()
			query = line.split("\t")[0]
			subject = line.split("\t")[1]
			identity = float(line.split("\t")[2])
			align_length = int(line.split("\t")[3])
			if identity >= 80 and align_length>=align_length_cutoff:
				D[subject]  = 0

	out = open(outListFile, "w")
	for key in D.keys():
		out.write(key+"\n")
	out.close()


def step4_find_list(workdir, outdir):
	print("Step 4: Find list")

	for subBlastOutDir in os.listdir(outdir):
		if os.path.isdir(outdir + "/" + subBlastOutDir):
			for locus in L_locus:
				print("\tFind list:\t" + subBlastOutDir + "\t" + locus)
				locus_BlastOutDir = outdir + "/" + subBlastOutDir + "/" + locus
				for R1_BlastOutFile in fnmatch.filter(os.listdir(locus_BlastOutDir), "*.R1.*.B.E06.O"):
					SeqHandle = R1_BlastOutFile.split(".")[0]
					R2_BlastOutFile = R1_BlastOutFile.replace(".R1.", ".R2.")
					BlastOutFile_listFile = SeqHandle + "." + locus + ".R18R2.B.E06.O.sbjct.list"

					if not os.path.exists(locus_BlastOutDir + "/" + BlastOutFile_listFile) or os.path.getsize(locus_BlastOutDir + "/" + BlastOutFile_listFile) == 0:
						findUniqBlastHitList([locus_BlastOutDir + "/" + R1_BlastOutFile, locus_BlastOutDir + "/" + R2_BlastOutFile],locus_BlastOutDir + "/" + BlastOutFile_listFile, 31)
					else:
						print("-----List is OK\t", BlastOutFile_listFile, "\t",os.path.getsize(locus_BlastOutDir + "/" + BlastOutFile_listFile))

					R1_FastQ_File = workdir + "/" + subBlastOutDir + "/" + R1_BlastOutFile.replace(".fasta.B.E06.O",".fastq.gz")
					R2_FastQ_File = workdir + "/" + subBlastOutDir + "/" + R2_BlastOutFile.replace(".fasta.B.E06.O",".fastq.gz")
					R1_HitReads_File = locus_BlastOutDir + "/" + R1_BlastOutFile.replace(".fasta.B.E06.O", "." + locus + ".fastq")
					R2_HitReads_File = locus_BlastOutDir + "/" + R2_BlastOutFile.replace(".fasta.B.E06.O","." + locus + ".fastq")

					if not os.path.exists(R1_HitReads_File) or os.path.getsize(R1_HitReads_File) == 0:
						cmd_Extract_HitReads_R1 = f"seqtk subseq {R1_FastQ_File} {locus_BlastOutDir}/{BlastOutFile_listFile} > {R1_HitReads_File}"
						print(f"seqtk subseq {R1_FastQ_File} {locus_BlastOutDir}/{BlastOutFile_listFile} > {R1_HitReads_File}")
						P = subprocess.Popen(cmd_Extract_HitReads_R1, shell=True)
						P.wait()
					else:
						print("-----R1_HitReads is OK\t", R1_HitReads_File, "\t", os.path.getsize(R1_HitReads_File))

					if not os.path.exists(R2_HitReads_File) or os.path.getsize(R2_HitReads_File) == 0:
						cmd_Extract_HitReads_R2 = f"seqtk subseq {R2_FastQ_File} {locus_BlastOutDir}/{BlastOutFile_listFile} > {R2_HitReads_File}"
						print(f"seqtk subseq {R2_FastQ_File} {locus_BlastOutDir}/{BlastOutFile_listFile} > {R2_HitReads_File}")
						P = subprocess.Popen(cmd_Extract_HitReads_R2, shell=True)
						P.wait()
					else:
						print("-----R2_HitReads is OK\t", R2_HitReads_File, "\t", os.path.getsize(R2_HitReads_File))


if __name__ == '__main__':
	print("Usage: Locus_Blast2_Trimmomatic_Batch_Using_multiprocessing.py <trimmomaticDir> <databaseDir> <outdir> [-g/--gene gene1 gene2 ...] [st int(default=32)] [bt int(default=32)]")
	print("Step04:\tExtract target-gene reads from Trimmomatic-cleaned paired-end data via BLAST and seqtk\n##########")

	workdir, databaseDir, outdir, marker, st, bt = main()
	if not os.path.exists(workdir):
		sys.exit("Error: input!!! input directory does not exist")

	os.makedirs(outdir, exist_ok=True)


	D_queryFile, L_locus = create_database_dict_and_get_L_locus(databaseDir,marker)
	step1_fastq_to_fasta(workdir, st)

	L_Process_formatdb = step2_make_formatdb(workdir)
	if L_Process_formatdb:
		print('current process {0}'.format(os.getpid()))
		p = multiprocessing.Pool(processes=4)
		for name in L_Process_formatdb:
			p.apply_async(run_formatdb, args=(name,))
		print('Waiting for all subprocesses done...')
		p.close()
		p.join()
		print('All processes done!')

	L_Process_Blast = step3_run_blast(workdir, D_queryFile, L_locus, bt)
	if L_Process_Blast:
		print('current process {0}'.format(os.getpid()))
		p = multiprocessing.Pool(processes=4)
		for name in L_Process_Blast:
			p.apply_async(run_blast, args=(name,))
		print('Waiting for all subprocesses done...')
		p.close()
		p.join()
		print('All processes done!')

	step4_find_list(workdir, outdir)
